— Можно вопросик по FieldCounter? Понятно, как установить всякие property геттеры, сеттеры, когда у нас одно поле, про которое мы хотим собирать статистику, но от чего нужно плясать, когда у нас много полей?
— Я пользовался  функцией property. Примерно так: setattr(cls, attr, property(getter, setter)). При этом getter и setter надо было заново изготавливать всякий раз, конечно.
— Я вот на него смотрю, и не очень понимаю, куда приделывать. Типо добавлять в класс методы setattr и getattr? Или где-то вызывать функции?
— Есть два пути: вернуть новый класс, унаследованный от старого или модифицировать пространство имён старого. Декоратор сработает и так, и так. Какой выбрать — в целом без разницы. Затем снова есть два пути. Вы можете в самом классе завести один большой словарь, в котором хранить счётчики всех объектов (словарь с индексами (объект, поле)). А можете в каждом объекте завести свой счётчик с индексом поле. В любом случае при создании/модификации класса надо с помощью vars() куда-то в него запомнить. какие поля вы собираетесь перебивать.
— Вот:
	Так становится понятнее, но непонятности остаются. Я, кажется, поняла, как задать вопрос. Вот есть пример:

class C:
    def init(self):
        self._x = None

    @property
    def x(self):
        """I'm the 'x' property."""
        return self._x

    @x.setter
    def x(self, value):
        self._x = value

    @x.deleter
    def x(self):
        del self._x

но тут мы можем собирать статистику только для изменения поля х. А как сделать так для рандомного поля?
— И тут есть снова два пути. Вы можете воспользоваться механизмом __setattribute__()/__getattr__(), чтобы перехватить обращение ко всем полям (придётся руками ходить в __dict__). Или вы каждое перебиваемое поле заменяете дескриптором. Почитайте документацию по setattr, я же не зря вам на это показал. Видите некоторую интересную особенность, отвечающую ровно на ваш вопрос? Какого типа второй параметр setattr()?
— да, там как раз передается name атрибута, но там третий параметр value, а вы передаете конструкцию с property и оно непонятно зачем и как.
— Как это зачем? Вам же нужно, чтобы вместо обычного поля там образовался дескриптор? Потому что при обращении к нему надо ещё посчитать. Ну property() тупо короче, чем эта возня с классами, а результат тот же, для этого и делалось. Единственное что, для каждого из полей getter и setter должен быть свой, т. е. когда в цикле будете пробегать все поля для перебития, не забудьте внутри этого цикла делать новые getter и setter. Видимо, вам стоит слегка поагрессивнее потыкать proprety. По идее, задачка была именно на него.
